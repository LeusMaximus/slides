# Объектное Реактивное Программирование

**[Дмитрий Карловский](https://github.com/nin-jin/)** из **[SAPRUN](http://www.saprun.com)** представляет... ммм...

> Это - текстовая версия выступления на [FrontendConf'17](http://frontendconf.ru/2017). Вы можете [читать её как статью](https://github.com/nin-jin/slides/tree/master/orp), либо [открыть в интерфейсе проведения презентаций](https://nin-jin.github.io/slides/orp/).

| Надоело.. | Чем поможет ОРП? |
|-----------|------------------|
| .. писать много, а делать мало? | Пиши мало, делай много!
| .. часами дебажить простую логику? | Реактивные правила обеспечат консистентность!
| .. асинхронщина? | Синхронный код тоже может быть неблокирующим!
| .. что всё по умолчанию тупит? | ОРП оптимизирует потоки данных автоматом!
| .. функциональные головоломки? | Объекты со свойствами - проще некуда!
| .. что приложение падает целиком? | Позволь упасть его части - само поднимется!
| .. жонглировать индикаторами ожидания? | Индикаторы ожидания пусть сами появляются, где надо!
| .. двустороннее связывание? | Двустороннее связывание нужно правильно готовить!
| .. пилить переиспользуемые компоненты? | Пусть компоненты будут переиспользуемыми по умолчанию!
| .. вечно догонять? | Вырывайся вперёд и лидируй!

# Рекламная пауза

![SAPRUN](company.png)

> Всем привет, меня зовут **Дмитрий Карловский**. Я - **руководитель группы веб-разработки** компании САПРАН. Компания наша является **крупнейшим интегратором САП-а** в России, но в последнее время мы активно смотрим в сторону разработки **собственных программных продуктов**.

# Реактивный до мозга костей

![**$mol**](mol.svg)

> Один из них - кроссплатформенный open source веб фреймворк быстрого построения отзывчивых интерфейсов с говорящим названием **"$mol"**. В нём мы по максимуму применяем возможности **Объектного Реактивного Программирования**, о которых я и расскажу далее...

# Что будем делать?

> Давайте представим, что мы решили **открыть интернет-магазин** по продаже игрушек. Причём сделать мы хотим всё не абы как, а **стильно, модно, молодёжно, быстро, гибко и надёжно**..

![Интернет-магазин](http://toys.hyoo.ru)

# Каталог товаров

> **Игрушек** у нас **много**, а начать продажи надо было ещё вчера. Поэтому мы хотим сделать всё как можно быстрее, но не про.. теряв user experience.

> Мы можем загрузить основные данные всех игрушек на клиентское устройство и позволить пользователю просматривать каталог **быстро, без сетевых задержек**.

![Каталог различных игрушек](toys.png)

# Фильтрация

> Листать наш огромный каталог, **конечно, увлекательно**, но пользователю хотелось бы ограничить его лишь теми игрушками, что особенно **интересуют его в данный момент**.

> Поэтому мы **добавляем фильтрацию**. Отфильтровать игрушки можно **по самым разным параметрам**: по размеру, по цене, по рейтингу, по тексту в описании, да много по чему.

![Каталог с фильтром](toys_filtered.png)

> На больших объёмах данных сложный фильтр может **накладываться продолжительное время**, поэтому для обеспечения отзывчивости нам бы не хотелось, чтобы фильтрация повторялась лишний раз, когда в ней нет необходимости.

> **Например**, если мы отфильтровали по тексту в описании, то нет смысла перефильтровывать каталог, когда меняется рейтинг какой-либо игрушки. Но если мы отфильтровали по рейтингу, то перефильтрацию в этом случае мы сделать уже обязаны.

> Поэтому важно знать от каких конкретно свойств каких конкретно товаров зависит результат фильтрации, чтобы перезапускать его только при изменении тех состояний, что **реально влияют** на результат.

# Сортировка

> Пользователь обычно хочет просматривать игрушки **не в произвольном порядке**, а в каком-то конкретном. Например: в порядке увеличения цены или в порядке уменьшения релевантности. Поэтому он должен иметь возможность указать критерий сортировки, который опять же может затрагивать различные свойства товаров и быть достаточно **тяжёлым на больших списках**.

![Каталог со сложным фильтром и сложной сортировкой](toys_sorted.png)

> Очевидно, тут повторную сортировку нужно будет произвести лишь при изменении **критерия сортировки**... или тех свойств товаров, **по которым мы сортировали*. Но не любых товаров, а лишь тех, что **соответствуют критерию фильтрации**. И, соответственно, при изменении **этого самого критерия**. А также, при изменении свойств товаров, **по которым мы фильтровали**. И...

# Учёт всех зависимостей

> Если вы попытаетесь **описать в коде** все зависимости между всеми состояниями, то произойдёт **комбинаторный взрыв** и вам оторвёт руки. 

![Диаграмма всех зависимостей между состояниями](all_deps.png)

> **Чтобы обуздать** эту экспоненциально растущую сложность, и было придумано Реактивное Программирование. Без него вы не сможете сделать сколь-нибудь сложное приложение **быстрым**, **надёжным** и **компактным** одновременно.

# Всё ли рендерить?

> Если вы будете **отображать все данные**, что подготовили, то алгоритмическая сложность рендеринга будет **пропорциональна объёму этих данных**. 10 товаров рендерятся мгновенно, 1000 - с задержкой, а если 10000, то пользователь успеет сходить попить чайку.

![График с линейной прогрессией](linear.png)

# Или не всё?

> Если у пользователя такой экран, что одновременно в него **влезает не более 10 товаров**, то визуально для него не будет никакой разницы - будете ли вы рендерить всю 1000 или только 10 из них. Поэтому, каким бы быстрым ни был у вас ~~React~~ шаблонизатор, он всегда будет **проигрывать по отзывчивости ленивой архитектуре**, которая в гораздо меньшей мере зависит от объёмов данных.

![График с логарифмической и линейной прогрессией](linear_log.png)

# Отображение лишь видимого

> Если **размеры карточек** нам примерно известны, то, зная **высоту окна**, легко понять какие товары **точно не видны**, а какие может хоть **краешком, но влезают** в видимую область. 

![Диаграмма вырезания видимой части списка товаров](only_visible.png)

> **Вырезать** из огромного списка элементы с первого по десятый - **плёвая операция**. Но только, если этот список у нас хранится где-то в **закешированном** виде. Если же мы при скроллинге будем **для каждого кадра** пересортировывать список, а то ещё и перефильтровывать его, то **ни о какой плавности** скроллинга не может идти и речи.

# Примерение изменений к DOM

> Ок, данные мы подготовили, осталось показать их пользователю. Решение в лоб - **удалить старое DOM-дерево и вырастить новое**. Именно так работают **все HTML-шаблонизаторы**.

![Перерисовывать DOM - это долго](render_html.png)

> К сожалению это **слишком медленно**. Кроме того, это **сбрасывает динамические состояния** узлов. Такие как: "позиция скроллинга", "позиция каретки" и другие. Некоторые из них потом можно восстановить программно, но далеко не все.

> Короче говоря, реальность упорно **не хочет быть чистой функцией**. Для повышения отзывчивости **нужно по возможности изменять существующее** состояние, а не просто создавать новое. А **если не можешь победить - возглавь!**

# Виртуальный DOM

> **Как натянуть ужа на ежа?** Правильно, давайте генерировать новое DOM дерево всего приложения, а потом ~~React~~ специальная библиотека будет сравнивать его новую и старую версию и **применять различия к тому DOM дереву** что реально видит пользователь.

![Виртуальный дом на каждый чих - это медленно](render_vdom.png)

> **Звучит как костыль, не правда ли?** Посмотрите на иллюстрацию - **сколько работы** приходится выполнять только лишь для того, чтобы, изменить значение **текстового узла**, когда в одной из моделей поменялось **строковое свойство**.

# Прямые зависимости

> Как могла бы выглядеть работа **наиболее эффективного** решения?

![Прямые зависимости. Что может быть эффективней?](render_orp.png)

> Всё просто - между исходными данными и их отображением устанавливаются **прямые связи**. При изменении одного состояния, изменяются **лишь зависимые от него**. Причём действует это не только между так называемыми "моделью" и "отображением", а **между любыми зависимыми состояниями**, начиная с записи в базе данных на сервере, через кучу промежуточных состояний и заканчивая дом-узлом в браузере. Именно в этом и заключается **суть Реактивного Программирования**, а не в шаблонизаторе с созвучным названием, который продают нам на каждой конференции.

# И так сойдёт!

![И так сойдёт!](not_on_my_shift.png)

> Вы можете сказать, что я сгущаю краски, а конкретно в вашем проекте никогда не будет **столько данных**, и **тяжёлой их обработки**, и запускать ваше приложение будут лишь на мощных рабочих станциях, а не на **хилом китайском тапке** в режиме энергосбережения.

# Треугольник серпинского на ReactJS

> Но на это у меня есть простое соображение. Для обеспечения плавности работы вашему приложению необходимо работать со скоростью в **60 кадров в секунду**, что даёт **всего 16 миллисекунд** на все операции, начиная с подготовки данных, и заканчивая пересылкой отрисованных областей в видеопамять. И превысить эти 16 миллисекунд очень просто даже в тривиальном приложении на мощном компьютере.

[![Тормозящий виртуальный DOM](http://nin-jin.github.io/sierpinski/stack.html)](http://nin-jin.github.io/sierpinski/stack.html)

> Перед вами демо созданное **ребятами из Facebook**, с целью демонстрации, как сильно виртуальный DOM сказывается на **отзывчивости сложного приложения**. Они это сейчас пытаются решить **размазыванием вычислений по кадрам**, что даёт заветные 60 кадров в секунду, но приводит к визуальным артефактам. **Фундаментальная же проблема** остаётся неизменной - виртуальный DOM требует **кучи лишних вычислений** на каждый чих.

# Треугольник серпинского с использованием ОРП

> ОРП, напротив, позволяет минимизировать объём вычислений, **автоматически оптимизируя потоки данных** от источника до потребителя.

[![Точечное обновление DOM в реальном времени](http://mol.js.org/perf/sierp/)](http://mol.js.org/perf/sierp/)

> Как вы можете видеть, даже **без размазывания** вычислений по кадрам, нам удаётся показывать **гораздо большую отзывчивость** приложения. И всё это благодаря **прямым реактивным связям** между исходными данными и зависящих от них DOM-узлами.

# Парадигмы

> Давайте добавим немного теории..

> Что такое **Объектное Программирование?** Основной его чертой является объединение данных и функций для работы с ними в рамках одной абстракции с относительно простым интерфейсом - объекте.

> А что такое **Функциональное Программирование?** Тут вся программа описывается в виде кучи чистых функций, которые не зависят от изменяемого состояния и сами не изменяют никаких состояний.

> Наконец, что такое **Реактивное Программирование?** Здесь вы описываете правила получения одних состояний из других таким образом, что изменение одного состояния приводит к каскадному изменению зависимых.

![Объектное, Функциональное и Реактивное](ofr_p.png)

> У многих Реактивное Программирование прочно ассоциируется с Функциональным, однако, оно куда ближе к Объектному, так как основные **действующие лица** в Реактивном Программировании - **изменяемые состояния**.

> И, хотя зависимости между состояниями зачастую описываются **в виде функций**, они вовсе не обязаны быть чистыми. Они **должны быть идемпотентными**, но об этом позже.

# Проталкиваем (ФРП)

> Есть два принципиально разных способа реализации реактивности.

> Первый - это всякие беконы, RX-ы и прочий стрим-панк, так же известный как **Функциональное Реактивное Программирование**. Суть его в том, что вы **явным образом** получаете так называемые стримы, от которых зависит ваше состояние, добавляете к ним **функцию вычисления** нового значения. И полученное таким образом значение уже **проталкивается** во все зависимые стримы, а что с этим значением делать или не делать они уже **решают сами**.

```typescript
const FilterSource = new Rx.BehaviorSubject( toy => toy.count > 0 )
const Filter = FilterSource.distinctUntilChanged().debounce( 0 )

const ToysSource = new Rx.BehaviorSubject( [] )
const Toys = ToysSource.distinctUntilChanged().debounce( 0 )

const ToysFiltered = Filter
.select( filter => {
	if( !filter ) return Toys
	return Toys.map( toys => toys.filter( filter ) )
} )
.switch()
.distinctUntilChanged()
.debounce( 0 )
```

> Посмотрите на этот **ФРП-ребус** и попробуйте сходу сказать, что и зачем он делает. А **делает он простую штуку**: создаёт стрим для товаров, стрим для критерия фильтрации и получает из них стрим отфильтрованного списка товаров.

> Тут уже применено несколько типовых оптимизаций. Тем не менее работает этот код очень не эффективно: список игрушек перефильтровывается даже если в товаре поменялись те данные, от которых результат фильтрации не зависит. Чтобы побороть эту проблему, придётся ещё на порядок усложнить код, но на это уже мало у кого хватит уситчивости.

> Данный подход приводит к сложному, трудноподдерживаемому коду. Его трудно читать. Его сложно писать. Его лень писать правильно. И в нём легко допустить ошибку, если вы, конечно, не финалист специальной олимпиады по информатике.

# Затягиваем (ОРП)

> Куда проще и эффективней использовать другой подход, где вычисления начинаются не от источника данных, а от их потребителя. Возьмём, например, самую продвинутую реализацию ОРП - [$mol_mem](https://github.com/eigenmethod/mol/tree/master/mem).

```typescript
class $my_toys {

	@ $mol_mem()
	filter( next ) {
		if( next === undefined ) return toy => toy.count() > 0
	
		return next
	}
	
	@ $mol_mem()
	toys( next = [] ){ return next }
	
	@ $mol_mem()
	toys_filtered() {
		if( !this.filter() ) return this.toys()
		
		return this.toys().filter( this.filter() )
	}
}
```

> Не правда ли ORP код куда проще, и понятнее? Это тот же код, который мы бы написали безо всякого реактивного программирования, но мы добавили специальный декоратор, который динамически отслеживает зависимости по факту обращения к ним, кеширует результат исполнения функции и сбрасывает кеш, когда зависимости изменяются.

> Правильная реализация логики этих декораторов позволяет производить вычисления наиболее оптимальным образом, не перекладывая головную боль по контролю потоков данных на прикладного программиста.

# Добавляем сортировку

> Аналогичным образом мы можем добавить и отсортированный список товаров, зависящий от функции сортировки и отфильтрованного списка.

> По умолчанию тут идёт сортировка по цене, а значит при изменении цены какой-либо игрушки из отфильтрованного списка, сортировка будет произведена вновь. А при изменении названия - не будет, если мы, конечно, не  фильтровали по названию - тогда сначала обновится отфильтрованный список, а затем уже и отсортированный.

```typescript
@ $mol_mem()
sorter( next ) {
	if( next === undefined ) return ( a , b )=> b.price() - a.price()
	
	return next
}

@ $mol_mem()
toys_sorted() {
	if( !this.sorter() ) return this.toys_filtered()
	
	return this.toys_filtered().slice().sort( this.sorter() )
}
```

# Отображаем лишь видимое

> Ну и под конец, мы вырезаем лишь видимые сейчас на экране товары. При этом перемещение скроллинга приводит лишь к незначительному по времени повторному вырезанию видимых задач, без бессмысленных перефильтраций и пересоровок.

```typescript
@ $mol_mem()
toys_visible() {
	return this.toys_sorted()
	.slice( ... this.view_window() )
}
```

> Сразу же введём свойство ```children```, которое будет возвращать компоненты, для рендеринга внутри нашего.

```typescript
children() {
	return this.toys_visible()
}
```

# Реактивный рендеринг: Переиспользуем DOM-узел

> Давайте реализуем теперь простейший обобщённый рендеринг компонента. Делать мы это будем в рамках вычисления свойства ```render```, знакомого всем реактоводам.

```typescript
@ $mol_mem()
render() {
	let node = document.getElementById( this.id() )
	
	if( !node ) {
		node = document.createElement( 'div' )
		node.id = this.id()
	}
	
	/// **Node updating here**
	
	return node
}
```

> Тут мы просто создаём дом узел и задаём ему идентификатор, если, конечно, не нашли уже существующий узел в DOM дереве с тем же идентификатором.

# Реактивный рендеринг: Обновляем состояние узла

> А теперь реализуем рендеринг вложенных компонент, добавление их внутрь нашего узла и обновление атрибутов. При изменении любых свойств, любых объектов, от которых зависит состояние этого DOM узла - рендеринг будет перезапущен и состояние DOM узла будет обновлено. Но обновление вложеyных узлов не будет приводить к обновлениию нашего, так как свойство ```render```всегда возвращает одно и то же значение.

```typescript
	/// **Node updating:**
	
	const child_nodes = this.children().map( comp => comp.render() )
	const attrs = this.attrs()
	
	node.innerHTML = ''
	for( let node of child_nodes ) {
		node.appendChild( node )
	}
	
	for( let name in attrs ) {
		node.setAttribute( name , attrs[ name ] )
	}
```

> При изменении имени игрушки, перезапущен будет лишь рендеринг названия этой игрушки, а при изменении позиции скроллинга, появившиеся карточки будут отрендерины, а ушедшие из области видимости - по тихому уничтожены. Эта простая схема позволяет точечно обновлять DOM не производя никаких лишних вычислений.

# А если исключение?

> Часто исключения безвозвратно ломают приложение. Оно может начать глючить, недорисовывать страницу или перестать реагировать на действия пользователя. Однако, исключение - такой же результат вычисления, как и собственно возвращаемое значение.

![Интернет-магазин c падающим сервисом](http://toys.hyoo.ru/#luck=.9)

> Если при рендеринге какого-то блока на странице произошло исключение, то именно этот блок и должен перестать работать, а всё остальное приложение должно продолжать работать, если это возможно. Но устранение причины исключения в последующем должно восстанавливать работу этого блока, как если бы он и не падал. 

# Защищаем приложение от падения компонента

> Поэтому давайте завернём рендеринг DOM-узла в блок ```try-catch``` и в случае ошибки, добавлять узлу специальный атрибут с именем исключения. А если исключения не произойдёт - наоборот стирать его.

```typescript
try {
	
	/// **Node updating here**
	
	node.removeAttribute( 'mol_view_error' )
	
} catch( error ) {
	
	console.error( error )
	
	node.setAttribute( 'mol_view_error' , error.name )
}
```

# Индикация ошибки

> Зачем нам этот атрибут? Да чтобы через CSS стилизовать сломанный блок, показывая пользователю, что он сейчас не работает. Например, мы можем сделать его полупрозрачным и запретить пользователю с ним взаимодействовать.

```css
[mol_view_error] {
	opacity: .5 !important;
	pointer-events: none !important;
}
```

# Загрузка: Синхронная блокирующая

> Давайте поговорим о загрузке данных. Взгляните на пример кода, который вычисляет сообщение о числе тёзок текущего пользователя. 

```typescript
namesakes_message() {

	/// **Serial**
	const user = this.user()
	const count = this.name_count( user.name )
	
	return this.texts().namesakes_message
	.replace( /\{count\}/g , count )
}
```

> Метод ```user``` делает запрос к серверу за информацией о пользователе, откуда берётся его имя и оно передаётся в метод ```names_count```, который запрашивает у другого сервера число пользователей с данным именем. Потом мы дёргаем метод ```texts```, чтобы получить тексты для текущей локали, берём оттуда нужный текст и подставляем в него полученное ранее число.

> Код простой и понятный, не правда ли? Но тут есть одна беда: пока выполняется каждый из этих трёх запросов всё приложение встаёт колом, так как виртуальная машина javascript однопоточна, а эти запросы блокируют поток до своего завершения.

# Загрузка: Асинхронная неблокирующая на Promise

> Чтобы решить эту проблему в яваскрипте принято присать код на колбэках. Например, в следующем коде используются так называемые "обещания".

```typescript
namesakes_message() {
	
	/// **Parallel**
	return Promise.all([
		
		/// **Serial**
		this.user().then( user => this.name_count( user.name ) ,
		
		this.texts() ,
	
	])
	.then( ([ count , texts ])=> {
		return texts.namesakes_message.replace( /\{count\}/g , count )
	} )
	
}
```

> Обратите внимание, что тут мы грузим информацию о числе пользователей и тексты паралельно, так как они не зависят друг от друга. Это ускоряет общую загрузку всех ресурсов, но поддерживать такой код - смерти подобно.

# Загрузка: Синхронная неблокирующая на async/await

> Недавно в яваскрипте появились средства синхронизации, но действуют они лишь в пределах одной функции, а не всего стека вызовов.

```typescript
/// **Serial**
async namesakes_count() {
	const user = await this.user()
	return await this.name_count( user.name )
}

async namesakes_message() {
	
	/// **Parallel**
	const [ count, texts ] = await Promise.all([
		this.namesakes_count() ,
		this.texts() ,
	])
	
	return texts.namesakes_message.replace( /\{count\}/g , count )
}
```

> Если мы пометили функцию как "асинхронную", то мы можем приостанавливать её до появления определённого события.

> Как видно, это не сильно спасает, так как для распараллеливания запросов всё равно приходится кастовать специальные заклинания.

# Загрузка: Синхронная неблокирующая используя ОРП

> А что если я скажу вам, что следующий код не смотря на всю свою синхронность может быть не только неблокирующим, но и грузить информацию о пользователе и тексты параллельно? 

```typescript
@ $mol_mem()
namesakes_message() {

	/// **Parallel**
	const texts = this.texts()
	const user = this.user()

	/// **Serial**
	const count = this.namesakes_count( user.name )
	
	return texts.namesakes_message.replace( /\{count\}/g , count )
}
```

> Вся магия в адекватной обработке исключительных ситуаций. Когда мы **синхронно запрашиваем** данные, а их нет - это самая натуральная **исключительная ситуация для синхронного** кода. Поэтому, кидается специальное исключение, которое **останавливает текущий стек вызовов**. Когда же данные придут, благодаря реактивности **исполнение будет перезапущено** и на этот раз данные уже будут возвращены, как ни в чём ни бывало.

# Загрузка: Автоматическое распараллелливание используя ОРП

> А чтобы добиться распараллеливания, реактивные свойства не пробрасывают исключение сразу, а возвращают **прокси объект**, который можно положить в переменную, куда-то передать, но при попытке доступа к его содержимому - будет брошено сохранённое исключение.

> В данном примере, **первое прерывание** произойдёт лишь при доступе к ```user.name```, а значит загрузка текстов и информации о пользователе пойдёт параллельно.

```typescript
@ $mol_mem()
namesakes_message() {

	/// **Parallel**
	const texts = this.texts()
	const user = this.user()

	/// **Serial**
	const count = this.namesakes_count( user.name ) /// **<-- first yield**
	
	return texts.namesakes_message.replace( /\{count\}/g , count )
}
```

# Загрузка: Игрушки

> Давайте добавим неблокирующую загрузку списка игрушек, вместо локального его хранения. Для этого нам потребуется изменить всего один метод.

```typescript
/// **Before**
@ $mol_mem()
toys(){ return [] }


/// **After**
@ $mol_mem()
toys() {
	const data = $mol_http.resource( '/toys.json' ).json()
	return data.map( id => this.toy( id ) )
}
```

> Как видите, нам не потребовалось менять его интерфейс - мы просто взяли содержимое файла, как если бы оно было у нас локально, обработали его и вернули результат.

# Индикация ожидания

> Остался последний штрих. Так как пока данные не загружены у нас бросается исключение, а имя исключения у нас автоматом прописывается в атрибуте DOM-элемента, который не смог отрендериться. А значит мы можем добавить этому блоку специальные стили, которые нарисуют анимированный индикатор ожидания. 

```css
[mol_view_error="$mol_atom_wait"] {
	animation: my_waiting .25s steps(6) infinite;
}
```

> В итоге у нас получилось, что любой блок на странице может в процессе рендеринга подождать загрузки данных и программисту не придётся везде вручную расставлять и убирать флаги переключающие видимость индикатора ожидания.

# Движение данных

> Пока что мы говорили лишь про движение данных от сервера к пользователю. Однако, стоит обратить внимание и на обратный поток данных.

![Взаимодействие пользователя с сервером через интерфейс](user_front_back.png)

> На диаграмме, каждое звено - некоторое состояние, выраженное в различных моделях. На бэкенде, например, дата у нас выражена числом в таблице. На фронтенде она уже представляется виджетом "календарик". Ну а в голове у пользователя это просто "тот день, когда я выступал на конференции".

> Если опустить посредников, то можно заметить, что **источником истины** о том, что видит пользователь является бэкенд, а источником истины о том, что следует изменить на бэкенде, является пользователь.

> Но самое интересное происходит, когда мы **добавляем посредников**. Например, пользовательский интерфейс, состояние которого зависит и от сервера и от пользователя. Как же реализовать его так, чтобы работал он чётко и предсказуемо?

# Двунаправленные зависимости

> Что если пользователь будет **менять не исходные данные**, а непосредственно то состояние, которое видит в **виджете, на который смотрит**?

![](angular_1.png)

# Двунаправленные зависимости: Меняем состояние виджета

![](angular_2.png)

# Двунаправленные зависимости: Меняем состояние страницы

![](angular_3.png)

# Двунаправленные зависимости: Меняем состояние модели

![](angular_4.png)

# Двунаправленные зависимости: Пришёл ответ от сервера

![](angular_5.png)

> **Как думаете, что за фреймворк тут использован?**

> Это типичное приложение на Angular. Когда пользователь меняет состояние, начинают срабатывать **watcher-ы, которые итеративно синхонизируют** состояния между собой, что приводит ко **временной неконсистентности** состояния клиент-серверной системы вцелом. Эта логика работы мало того, что **не эффективна**, так ещё и требует **очень аккуратного написания** кода с **точно подогнанными костылями** вида "подождать пока всё синхронизируется, а потом вызвать обработчик".

# Однонаправленный поток данных

> **А как называется архитектура со следующей диаграммы?**

![](flux_1.png)

# Однона... что это у нас?

![](flux_2.png)

# Потока хоть и два, но не пересекаются

![](flux_3.png)

> Facebook подумал-подумал и придумал [FLUX](https://facebook.github.io/flux/), где поток от сервера к пользователю идёт через компоненты, а **обратно - через глобальные процедуры** - так называемые "Экшены". 

> Написание компонент стало относительно простой задачей, но только до тех пока, пока они лишь выводят информацию. Как только вы заходите, чтобы пользователь мог не только смотреть в приложение, но что-то в нём изменять, то у вас появляется проблема с созданием переиспользуемых компонент.

> Проще говоря, вы не можете просто взять и использовать такой компонент, не реализовав для каждого места его использования набор отдельных глобальных процедур. Пол века назад эта проблема уже была решена за счёт абстракции и инкапсуляции, но до сих пор мы ходим по одним и тем же граблям.

# Двусторонние каналы: Прямой поток

> Проблема двустороннего связывания Агнуляра была не в том, что оно двустороннее, а в том, что состояние сначало изменялось, а потом отложенно синхронизировалось. Причём меняться оно могло как с одной стороны, так и с другой. Именно в этом был корень всех проблем. Как же его выкорчавать? 

![](channels_1.png)

# Двусторонние каналы: Обратный поток

> Решение в Объектном Программировании опять же существует не один десяток лет - не давать напрямую изменять состояние. Вместо этого доступ к состоянию реализуется через специальные функции - так называемые "акцессоры". Пользователь объекта может лишь изъявить желание поменять значение определённого свойства, а что с этим значением делать или не делать - объект уже решает сам.

![](channels_2.png)

# Двусторонние каналы: Обратный поток

> На диаграмме можно видеть, как новое значение передаётся от объекта к объекту не меняя их состояний. И только когда приходит ответ от сервера с актуальным значением, оно спускается по иерархии компонент, меняя их состояние.

![](channels_3.png)

> У этой архитектуры нет проблем Ангуляра с неконсистентностью, ведь прямой и обратный потоки данных не перемешиваются. Но нет и проблем FLUX-а, так как каждый компонент взаимодействует лишь со своим непосредственным владельцем и непосредственным имуществом.

> Всё, что нужно, чтобы повторно использовать какой-либо компонент - это создать экземпляр и настроить его под себя, предоставив ему так называемые "свойства" - это своего рода двусторонние каналы, из которых можно затянуть актуальные данные и предложить новые.

# Абстракции

> В простейшем случае компонент - это экземпляр определённого класса. Интерфейс этого класса состоит из методов-акцессоров, они могут работать как с локальным состоянием, так и делегировать получение и изменение значения методам другого объекта.

```typescript
class $mol_string {
	
	hint() { return '' }
	
	@ $mol_mem()
	value( next = '' ) { return next }
	
	// ...
}
```

> Данный пример - строковое поле ввода. Для иллюстрации приведено два свойства: ```hint``` - это текст показываемый, если значение поля не задано; и ```value``` - это текущее значение. Когда пользователь вводит новое значение оно передаётся в value. Соответственно тут мы можем это значение как-то нормализовать, провалидировать, куда-то сохранить. В данном случае мы используем декоратор, чтобы значение ```value``` кешировалось локально в текущем объекте.

# Одностороннее переопределение

> Чтобы настроить поведение компонента мы можем просто переопределить его свойства своими функциями. Например, можем сделать, чтобы ```hint``` возвращал известного персонажа комиксов.

```typescript
const Name = new $mol_string

Name.hint = ()=> 'Batman'
```

# Двустороннее переопределение

> Или можем попросить компонент в качестве ```value``` брать не своё локальное состояние, а нашу локальную переменную.

```typescript
let name = 'Jin'

Name.value = ( next = name )=> {
	return name = next
}
```

> Тут мы просто говорим, что при *затягивании* из ```value``` нужно вернуть значение переменной ```name```, а при *проталкивании* - записывать в ```name``` и возвращать актуальное значение.

> Вам может показаться, что это дурнопахнущий код, так как мы берём и переопределяем любой метод стороннего объекта, но на практике это всё отлично работает и не доставляет проблем.

> Мы не можем записать левый метод или изменить сигнатуру существующего, иначе тайпчекер настучит нам по башке. Единственное оганичение, которого очень просто придерживаться, это: компонент не должен ничего делать в своём конструкторе, а переопределять методы можно лишь один раз при создании объекта.

# Связывание владельца с имуществом

> Лучше, конечно, не создавать объекты в воздухе и не разбрасываться локальными переменными. Давайте реализуем компонент, который будет владеть нашим полем ввода и контролировать его жизненный цикл.

```typescript
	@ $mol_mem()
	Name() {
		const next = new $mol_string

		next.hint = ()=> this.name_hint() /// **One way binding**
		next.value = next => this.name( value ) /// **Two way binding**

		return next
	}
```

> Тут мы используем реактивное свойство ```Name``` в качестве фабрики, которая лениво создаёт и настраивает компонент. Созданный компонент кешируется и при последующих обращениях к фабрике сразу возвращается. Кроме того, как только визуализация перестанет зависеть от этого компонента, кеш будет уничтожен вместе с компонентом ```$mol_string```. Это гарантирует нам правильное и своевременное освобождение занятых им ресурсов.

> Также, стоит обратить внимание, что интерфейс нашего компонента по преждему состоит из свойств, но при настройке вложенного компонента мы связываем наши свойства со свойствам поля ввода. Свойство ```hint``` фактически имеет односторонню связь со свойством ```name_hint```. Мы сможем его изменять, а поле ввода его изменить не сможет при всём желании. А вот ```value``` с ```name``` связаны двусторонне, так что поле ввода сможет и читать, и писать в наше свойство ```name```.

# Связывание независимых компонент

> Допустим у нас есть два компонента, которые знают друг о друге чуть менее, чем ничего. Например: поле ввода строки и поле вывода текста. Используя технику переопределения свойств мы можем провязать их друг с другом таким образом, что изменение текста в поле ввода будет тут же отражаться в изменении приветствия в поле вывода.

```typescript
	@ $mol_mem()
	name( next ) {
		return next || 'Annon'
	}

	@ $mol_mem()
	Name() {
		const next = new $mol_string
		next.value = next => this.name( value )
		return next
	}
```

```typescript
	message() {
		return `Hello, ${ this.name() }`
	}

	@ $mol_mem()
	Message() {
		const next = new $mol_string
		next.value = ()=> this.message()
		return next
	}
```

> В данном примере мы создаём в нашем компоненте два дополнительных свойства ```name``` и ```message```, которые уже тривиально связываем со свойствами вложенных компонент и друг с другом. Таким образом, тот, кто будет использовать наш компонент, сможет легко и просто настроить его под себя. Например: изменить значение имени по умолчанию или алгоритм формирования приветственного сообщения.

# Изменение собственной зависимости

> Пришло время поговорить об ограничениях реактивного программирования. Как я упоминал ранее - это идемпотентность. Суть её в том, что результат работы функции не должен меняться от вызова к вызову. Под результатом работы тут понимается не только возвращаемое значение, но и все те побочные действия, что она производит. Любая чистая функция является идемпотентной, но не всякая идемпотентная функция чиста. Например, функция рендеринга, что мы описали ранее - идемпотентна, так как при неизменных зависимостях, её повторный вызов не приводит к изменению DOM-дерева.

> А вот пример неидемпотентной функции: мы читаем значение, увеличиваем его на 1, и записываем обратно.

```typescript
@ $mol_mem()
increment() {
	this.value( this.value() + 1 )
}
```

> Каждый раз, в процессе её работы меняется значение ```value```, от которого она зависит, что приводит к вызову её снова и снова. Поэтому реактивное программирование нельзя применять для подобных функций. Мы могли бы отказаться тут от реактивности, но тогда мы бы потеряли возможность делать синхронные неблокирующие запросы.

# Реактивные задачи

> Решением являются так называемые "реактивные задачи", которые самоуничтожаются по завершении, и которые можно выстраивать в цепочки, как обещания.

```typescript
increment() {
	new $mol_atom( `${ this }.increment()` )
	.then( ()=> this.value() + 1 )
	.then( next => this.value( next ) )
}
```

> Тут мы разбиваем нашу функцию увеличения числа на две отдельные реактивные задачи: первая вычисляет новое значение, а вторая записывает вычисленное значение обратно. Код внутри них вполне себе синхронный и может приводить к неблокирующим запросам. Но исполняется каждая задача ровно один раз, после чего передаёт управление следующей.



# Резюме

Реактивное программирование - **каскадное изменение** состояний по нашим правилам.

ОРП провоцирует **простой**, **понятный**, но **эффективный** код.

Ленивая архитектура **минимизирует объём** вычислений.

**Потока** данных **всегда два** и они не должны пересекаться.

**Синхронный** код - **добро**.

**Ручное** управление потоками данных - **зло**.

> Напоследок хотелось бы дать совет: не гонитесь за хайпом. Мода переменчива и часто тащит нас в болото. Разумеется большой компанией выбираться из жопы интересней. Но если вы хотите вырваться вперёд, пока остальные буксуют, нужно учиться трезво и рационально оценивать технологии, выбирая те, что уменьшают сложность разработки, а не увеличивают её. Если ваш единственный аргумент - число разработчиков "знающих" технологию, то готовьтесь к тому, что через пару лет никто из них уже не захочет с ней связываться, а ещё через пару - вы не найдёте никого, кто смог бы разобраться в коде проекта. ОРП же позволяет писать простой, компактный, ясный и эффективный код, который тебует ломать себе мозг, чтобы объяснить компьютеру, что ты от него хочешь.

# Вопросы?

> На этом у меня всё. Если у вас возникли какие-либо вопросы, я с радостью на них отвечу.

Реализации ОРП: [$mol_mem](https://github.com/eigenmethod/mol/tree/master/mem), [VueJS](http://vuejs.org), [MobX](https://mobx.js.org), [CellX](https://github.com/Riim/cellx), [KnockOut](http://knockoutjs.com)

Получившийся магазин: [toys.hyoo.ru](http://toys.hyoo.ru)

Исходники магазина: [github.com/nin-jin/toys.hyoo.ru](http://github.com/nin-jin/toys.hyoo.ru)

Эти слайды: [nin-jin.github.io/slides/orp](https://nin-jin.github.io/slides/orp/)

Треугольники Срепинского: [github.com/nin-jin/sierpinski](https://github.com/nin-jin/sierpinski)