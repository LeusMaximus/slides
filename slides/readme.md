# Презентация приложения для проведения презентаций

| Дмитрий Карловский @ PiterJS#40 |
|---------------------------------|

Здравствуйте, меня зовут Дмитрий Карловский и я иногда выступаю на конференциях. А это - [презентация веб приложения для проведения презентаций](https://slides.hyoo.ru/) ([видеозапись этого выступления](https://www.youtube.com/embed/jcV-OS6OvLY)), которое я и использую для своих выступлений. Всё, что вам нужно для его запуска - это обычный веб браузер и доступ в интернет. Далее вы узнаете, сколько всего оно умеет, и как сделать такое же своими руками всего за один вечер.

# Интерфейс слушателя

![Презентация в режиме слушателя](https://slides.hyoo.ru/#slides=https%3A%2F%2Fnin-jin.github.io%2Fslides%2Forp%2F/slide=2/role=listener)

Перед вами интерфейс, который видят слушалели во время выступления. В нём нет ничего лишнего.

Сверху выводится название и номер слайда. У слушателей могут возникнуть вопросы. И быстро записав этот номер, они смогут после выступления назвать его и тем самым избавить аудиторию от утомительного ожидания, когда же докладчик найдёт слайд, по которому задаётся вопрос.

Внизу можете обратить внимание на прогресс бар, показывающий опоздавшим слушателям сколько они пропустили. А всем остальным - сколько ещё осталось до конца. Рассчитывается он не по числу слайдов, а по объёму рассказанной речи.

# Смотри как я могу

Основаня идея в том, чтобы позволить докладчику сконцентрироваться на содержимом и не беспокоиться об оформлении. Докладу вовсе не нужны какие-то особые красоты и эффектные анимации. Иначе оформление будет перетягивать внимание на себя. А содержание рискует пролететь мимо ушей.

![Потому, что я - Бэтмен!](https://github.com/nin-jin/slides/raw/master/slides/batmen.png)

Но оформление тем не менее должно быть всё же опрятным, чтобы не портить впечатление о докладе. Поэтому дизайн приложения простой, не броский, и, что самое главное, соответствующий рекомендациям программых комитетов.

# Интерфейс докладчика

Интерфейс докладчика разделён на две части.

![Презентация в режиме докладчика](https://slides.hyoo.ru/#slides=https%3A%2F%2Fnin-jin.github.io%2Fslides%2Forp%2F/slide=2)

Слева отображается то, что видят слушатели. А справа - заметки докладчика. Они помогут вам вспомнить потерянную мысль, не отворачиваясь от слушателей и не напрягая их долгой.. эм... это.. паузой.

# Главное - контент

Поэтому в нашем случае контент пишется как статья в формате MarkDown и выкладывается на какой-нибудь GitHub Pages. А всё остальное берёт на себя веб-приложение.

```markdown
  # Название первого слайда

  Содержимое первого слайда

  # Название второго слайда

  Содержимое второго слайда
```

И размеется эту статью в таком виде вы можете опубликовать где-нибудь. Например, на Хабре. И она даже будет вполне читаемой. Два зайца по цене одного.

# Стили текста

Обычный текст отображается только докладчику. А всякие картинки, списки, таблицы, цитаты и тп штуки видны всем. 

```markdown
  - *Акцент*
  - **Сильный акцент**
  - ~~Удаление~~
  - ```Код```
```

- *Акцент*	
- **Сильный акцент**	
- ~~Удаление~~
- `Код`	

Разумеется доступны и различные средства инлайн форматирования текста. Такие как: акцент, сильный акцент, удалённый текст и, конечно, код.

# Исходные коды

Блоки исходного кода, разумеется, тоже поддерживаются, и раскрашиваются во все цвета радуги. Прям как вы любите.

```markdown

    ```javascript
    const hello = ()=>
    <body>
        Hello, "world"!
    </body>
    ```

```

```javascript
const hello = ()=>
<body>
    Hello, "world"!
</body>
```

# Таблицы

Сравнивать различные штуки вам помогут таблицы.

```
    |               | GZipped Size |
    |---------------|--------------|
    | @angular/core |    **86** KB |
    | ReactDOM      |    **34** KB |
    | $hyoo_slides  |    **29** KB |
```

|               | GZipped Size |
|---------------|--------------|
| @angular/core |    **86** KB |
| ReactDOM      |    **34** KB |
| $hyoo_slides  |    **29** KB |

Для примера, можете сравнить сколько весит ядро Angular, библиотека рендеринга React и вообще весь код данного приложения. Как видите, на популярных во фронтенде технологиях в принципе не достичь того же уровня компактности. Ну да ладно, таблицы - это скучно.

# Картинки

Держите котейку.

```markdown
  ![Котейка](https://github.com/nin-jin/slides/raw/master/slides/cat.gif)
```

![Котейка](https://github.com/nin-jin/slides/raw/master/slides/cat.gif)

Обратите внимание, что фон слайдов слегка серый. Поэтому изображения лучше готовить не на белом фоне, а с прозрачностью, чтобы вокруг картинок не было неприятного белого прямоугольника. Сделано это, чтобы белые области смотрелись контрастно, а не сливались с фоном.

# Видео

Можно размещать видео, веб страницы и любой другой внешний контент, используя тот же MarkDown синтаксис, что и для вставки картинок. 

```
  ![Нецелевая аудитория](https://www.youtube.com/embed/exfBX2pb7AQ?autoplay=1)
```

![Нецелевая аудитория](https://www.youtube.com/embed/exfBX2pb7AQ?autoplay=1)

Для примера я вставил видео иллюстрирующее, что современные интерфейсы настолько простые и удобные, что с ними справится даже обезьяна.

# Кликер сломался

Вы, наверно, думаете, что в зале у меня тут где-то есть засланный казачок, который переключает слайды вместо меня? Однако, это не так.

- **Дальше**, пожалуйста.
- **Назад**, пожалуйста.
- **Слайд номер** 5, будь добра.
- **На начало**, пожалуйста.
- **В конец**, пожалуйста.
- **Найди** "котейку", будь добра.
- **Повтори**, пожалуйста.
- **Помолчи**, будь любезна.
- **Продолжай**, пожалуйста.
- **Выключи свет**, будь любезна.

Повтори, пожалуйста. *Голос свыше повторяет последнюю фразу.*

Да, слайдами можно полностью управлять голосом, оставляя свои руки свободными для жестикуляций.

# Структура приложения

Давайте приоткроем капот и посмотрим, как устроено приложение, и что ещё оно умеет, чего не видно с первого взгляда.

```tree
$hyoo_slides_page $mol_view

    sub /
        <= Listener
        <= Speaker
```

```tree
export class $hyoo_slides_page extends $mol_view {
    
    sub() { return [
        this.Listener() ,
        this.Speaker() ,
    ] }

}
```

Перед вами верхнеуровневое описание одного экрана на языке [view.tree](https://github.com/eigenmethod/mol/tree/master/view#viewtree) и эквивалентный код на TypeScript. Тут мы объявляем компонент `$hyoo_slides_page`, который расширяет базовый компонент `$mol_view`. У этого компонента есть свойство `sub`. Всё, что возвращает это свойство, будет отрендерено внутри компонента. Поэтому мы переопределяем его, передавая в качестве значения массив из двух элементов: `Listener` - компонент вывода слайда слушателям и `Speaker` - компонент дополнительной панели докладчика.

# Переключение раскладки страницы

В дополнение к описанию структуры мы можем приложить и программную логику, позволяющую любые свойства вычислять динамически.

```tree
sub() {

    const role = this.role()

    return [
        this.Listener() ,
        ... ( role === 'speaker' ) ? [ this.Speaker() ] : [] ,
    ]

}
```

Тут логика у нас простая: слайды для слушаетелей выводим всегда, а вот панель докладчика показываем только, если текущая роль - `speaker`. Если роль изменится, то и раскладка приложения тоже изменится благодаря магии объектного реактивного программирования.

# Роутинг

Роль мы будем брать из параметра адреса, через специальный реактивный API.

```typescript
role() : 'speaker' | 'listener' {

    return $mol_state_arg.value( 'role' ) || 'speaker'

}
```

По какой бы причине ни поменялся адрес - роль будет извлечена из него автоматически, и проведена через в этот метод.

# Структура интерфейса слушателя

Давайте опишем интерфейс слушателя.

```tree
Listener $mol_page

    title <= title

    tools /
        <= Slide_switcher

    body /
        <= Listener_content
        <= Progress
```

Он использует стандартный компонент `$mol_page` который рисует типичную страницу с шапкой и телом. В шапке есть область, куда выводится название страницы. Через свойство `title` можно указывать, что туда выводить. Что мы и сделали, связав его свойство `title` с нашим одноимённым свойством. Теперь, меняя наше свойство, мы полностью контролируем, что будет выводиться на странице в качестве заголовка.

Справа в шапке, есть область вывода доволнительных инструментов - `tools`. В неё мы выводим `Slides_switcher` - компонент для отображения номера слайда и передключения между соседними слайдами.

И, наконец, в качестве тела страницы в `body` мы выводим содержимое слайда и прогресс бар.

# Структура переключателя страниц

Как же реализовать `Slide_switcher`? Просто используем стандартный компонент `$mol_paginator`.

```tree
Slide_switcher $mol_paginator

    value?val <=> slide?val
```

Всё, что у него есть - это изменяемое свойство `value`, которое мы двусторонне связываем с нашим свойством, содержащим номер текущего слайда. Никаких импортов, колбэков, событий и прочего хлама. Эти две строчки - это всё, что необходимо, чтобы у вас на странице появился работающий переключатель страниц.

# Структура содержмого слайда

Для отображения содержимого слайда мы воспользуемся опять же стандартным компонентом `$mol_text`.

```tree
Listener_content $mol_text

    uri_base <= uri_base

    text <= listener_content
```

Он принимает текст в формате `markdown` и визуализирует его. Так как ссылки в этом тексте будет относительно исходного файла, а не нашего приложения, то в свойство `uri_base` мы передаём ссылку, относительно которой будут резолвиться все пути.

# Структура индикатора прогресса

Как вы уже, наверно, догадались для отображения прогресса тоже есть стандартный компонент.

```tree
Progress $mol_portion

	portion <= progress
```

```
portion: [ 0 .. 1 ]
```

Скармливаем ему число от 0 до 1 и получаем заполненую на эту долю индикатор.

# Структура интерфейса докладчика

В интерфейсе докладчика у нас есть кое-что по интересней. Отображаемые в шапке инструменты никак не привязаны к текущей странице - они общие для всего приложения. Поэтому вместо того, чтобы хардкодить их тут, мы разместим ту лишь слот `speaker_tools`, в который будем помещать компоненты извне.

```tree
Speaker $mol_page

    head <= speaker_tools /

    body /
        <= Speaker_content
```

# Структура приложения

Теперь поднимемся уровнем выше и создадим компонент приложения `$hyoo_slides`, который использует компонент страницы.

```tree
$hyoo_slides $mol_view

	Page!index $hyoo_slides_page
        - ...

	plugins /

        <= Nav
        <= Touch
        <= Speech_next

        - ...
```

# Настройка страницы извне

```tree
Page!index $hyoo_slides_page

    role <= role
    
    slide?val <=> page_slide!index?val

    speaker_tools /

        <= Speech_toggle
        <= Speech_text
        <= Open_listener
```

# Структура переключателя голосового управления

```tree
Speech_toggle $mol_check_icon

    Icon <= Speech_toggle_icon $mol_icon_microphone

    checked?flag <=> speech_enabled?flag
```

# Структура кнопки открытия ведомого окна

```tree
Listener_open $mol_link

    target \_blank

    arg *
        role \listener
        slide null

    sub /
        <= Listener_open_icon $mol_icon_external
```

# Плагины

```tree
plugins /

    <= Nav
    <= Touch
    <= Speech_next
    <= Speech_prev
    <= Speech_start
    <= Speech_end

    - ...
```

# Клавиатурная навигация

```tree
Nav $mol_nav

    keys_y <= slide_keys
    keys_x <= slide_keys

    current_y?val <=> slide?val
    current_x?val <=> slide?val
```

```
keys: [ 0 , 1 , 2 , 3 , ... , 30 ]
                ^
             current
```

# Жесты пальцем

```tree
Touch $mol_touch

    swipe_to_left?event <=> go_next?event
    swipe_to_right?event <=> go_prev?event
```

```typescript
go_next( event? : Event ) {
    this.slide( this.slide() + 1 )
}
```

# Голосовое упраление

```
Sing $mol_speech

    event_catch?val <=> sing?val

    patterns /
        \sing( \S+?)*
        \спой( \S+?)*
```

# Автоматическое переключение слайдов

```
Speech_next_auto $mol_speech

    event_catch?val <=> go_next?val

    suffix \

    patterns <= speech_next_auto_patterns
```

# Запуск приложения

```html
<body mol_view_root="$hyoo_slides">
    <script src="web.js" charset="utf-8"></script>
</body>
```

# Оффлайн

```tree
hyoo/slides/slides.meta.tree

include \/mol/offline/install
```

# Печать в PDF

```
sub() {

    if( !this.$.$mol_print.active() ) {

        return [ this.Page( this.slide() ) ]

    }

    return $mol_range2(

        index => this.Page( index ) ,
        
        ()=> this.slide_keys().length ,

    )

}
```

# Как создать презентацию

Попробовать в деле `$hyoo_slides` можно очень просто. Вам потребуется `readme` с вашим контентом и картинки. Так же рядом нужно будет скопипастить [`index.html`](https://github.com/nin-jin/slides/blob/master/slides/index.html), который редиректнет на веб приложение и откровет вашу презентацию в нём. 

- `readme.md`
- `index.html`
- картинки
- статический хостинг

Имейте ввиду, что этот `index.html` будет выдавать приложению любые файлы, доcтупные с того домена, куда вы всё это дело выложите. GitHub Pages - вполне удобный и безопасный вариант. Сам его использую.

# Другие приложения

Если вам понравилось это приложение, то можете глянуть и другие интересные приложения, реализованные на фреймворке $mol. Они настолько легковесные, что даже несколько десятков их не страшно загрузить разом на одном слайде.

![Галерея приложений](https://showcase.hyoo.ru/)

Но о них в другой раз... 

# Примеры презентаций

Подробнее о фреймворке можно узнать на отдельной презентации. Копнуть глубже можно в презентации посвящённой ОРП. А приподнять завесу грядущего можно в презентации о квантовании вычислений.

- [$mol - лучшее средство от геморроя](https://github.com/nin-jin/slides/edit/master/mol/)
- [Объектное Реактивное Программирование](https://github.com/nin-jin/slides/edit/master/orp/)
- [Quantum Mechanics of Calculations](https://github.com/nin-jin/slides/edit/master/fibers/)
- [slides.hyoo.ru](https://slides.hyoo.ru/)

Все они используют $hyoo_slides для отображения. Надеюсь вскоре таких презентаций станет больше. Спасибо за внимание!
