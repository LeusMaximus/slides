# Объектно Ориентированное Реактивное Программирование

Доклад: Объектно Ориентированное Реактивное Программирование

Докладчик: Дмитрий Карловский

Слайды: [http://nin-jin.github.io/slides/oorp/](http://nin-jin.github.io/slides/oorp/)

> Привет всем землянам, меня зовут Дмитрий Карловский и я.. не буду строить из себя успешного разработчика, прикрываясь крупной фирмой за плечами, продавать вам модную технологию, которая решит одни пробелемы, создав другие. Доклад мой будет о незаслуженно непопулярной, но весьма элегантной парадигме.

> Кто знает что такое Объектное Программирование?

> Кто знает что такое Функциональное Программирование?

> Кто знает что такое Реактивное Программирование?

> У многих Реактивное Программирование прочно ассоциируется с Функциональным, однако, оно куда ближе к Объектно Ориентированному, так как основные действующие лица в Реактивном Программировании - состояния, изменяемые каскадно. И, хотя зависимости между состояниями зачастую описываются в виде функций, они вовсе не обязаны быть чистыми, но должны быть идемпотентными, но об этом позже..

# Вся тяжесть зависимости

## Список задач

> Представьте, что вам надо реализовать менеджер задач. Причём не абы как, а стильно, модно, молодёжно, быстро, гибко и надёжно..
> Типичное число задач в аккаунте - порядка десятка тысяч, что позволяет нам выгрузить все данные на клиентское устройство и работать с ними без сетевых задержек.
> Но в некоторых долгоживующих аккаунтах число задач может доходить и до сотни тысяч, а в каждой задаче может быть до пары десятков полей с данными. По объёму это относительно много, но пользователь не против с утра немного подождать загрузки лишь бы потом всё летало.

![Список из 99 999 задач](tasks.svg)

> Тут у нас схематично изображён список из большого числа задач, для каждой из которых отмечено три свойства: название, оценка времени и статус "открыта/закрыта".

## Добавляем фильтрацию

> Но обычно пользователю не нужны вообще все задачи, а только лишь их часть, соответствующая некоторым критериям.

![Отфильтрованный список на порядок меньше](tasks-filtered.svg)

> В данном примере, мы оставили в списке лишь задачи со статусом "открытая", но реальные критерии могут быть самыми разнообразными и затрагивать различные поля задач, в том числе и разные поля у разных задач. Поэтому выполнение сложного фильтра на большом объёме данных может быть ощутимо продолжительной операцией, а значит чем реже нам её потребуется запускать, тем отзывчивее будет приложение.

> В данном случае, очевидно, повторная фильтрация нам потребуется в случае изменения критериев фильтрации, или изменении статуса одной из задач. Но если при изменении названия задачи мы будет перезапускать фильтрацию - это будут тормоза на ровном месте. Поэтому важно знать от каких конкретно свойств каких конкретно задач зависит результат фильтрации, чтобы перезапускать его только при изменении тех состояний, что реально влияют на результат.

## Добавляем сортировки

> Пользователю обычно нужно просматривать задачи не в произвольном порядке, а в каком-то конкретном. Поэтому он должен иметь возможность указать критерии сортировки, которые опять же могут затрагивать различные свойства задач и быть достаточно прожорливыми на больших списках.

![Сортировка задач - тоже не простая задача](tasks-filtered-sorted.svg)

> Тут мы, для примера, мы добавили сортировку по сроку выполнения задачи. Очевидно, повторную сортировку нужно будет произвести лишь при изменении критерия сортировки... И срока исполнения, но не всех задач, а только если срок меняется у задач, отфильтрованных по критерию фильтрации... И, соответственно, при изменении критерия фильтрации. И...

## Учёт всех зависимостей

> Если вы попытаетесь в коде описать все зависимости между данными, то это приведёт к комбинаторному взрыву и вам оторвёт руки. 

![Вроде все зависимости или я что-то не учёл?](tasks-filtered-sorted-deps.svg)

> При этом важно, чтобы вычисления происходили в правильном порядке. Если мы пересортируем список, потом перефильтруем, то затем нам снова придётся сортировать, но уже новый результат фильтрации. Получается первую фильтрацию мы делали зря. А ведь это время, задержки, злой пользователь, крутящий мышью вокруг застывшей анимации.

> Вы можете сказать, что я сгущаю краски, а конкретно в вашем проекте никогда не будет столько данных, и тяжёлой их обработки, и открывать ваше приложение будут лишь на мощных рабочих станциях, а не на хилом китайском тапке в режиме энергосбережения.

> На это у меня есть простое соображение. Для обеспечения плавности работы вашему приложению необходимо работать со скоростью в 60 fps, что даёт всего 16 миллисекунд на все операции начиная с подготовки данных, заканчивая пересылкой отрисованных областей в видеопамять. И превысить эти 16 миллисекунд очень просто даже в довольно простом приложении на довольно мощном компьютере.

## Отображение лишь видимого

> Если вы будете отображать все данные, что подготовили, то алгоритмическая сложность рендеринга будет пропорциональная объёму данных. 10 задач рендерятся мгновенно. 1000 задач рендерится уже пару секунд. Если у пользователя такой экран, что одновременно в него влезает не более 10 задач, то визуально для него не будет никакой разницы - будете ли вы рендерить всю 1000 или только 10 из них. Поэтому, каким бы быстрым ни был у вас ~~React~~ шаблонизатор, он всегда будет проигрывать по отзывчивости архитектуре с ленивым рендерингом, которая в гораздо меньшей мере зависит от объёмов данных.

![Мгновенно остаётся лишь видимая часть списка](filtered-sorted-visible.svg)

> Если высота каждой строки нам известна заранее, то, зная высоту окна, легко понять какие задачи точно не видны, а какие может хоть краешком но влезают в видимую область. Вырезать из огромного списка элементы с первого по девятый - плёвая операция. Но только, если этот список у нас хранится где-то в закешированном виде. Если же мы при скроллинге будем на каждый фрейм пересортировывать список, а то ещё и перефильтровывать его, то у нас всё приложение встанет колом.

> К чему это я? А к тому, что красивая абстракция "DOM как чистая функция от состояния" течёт по швам. Для повышения отзывчивости необходимо вводить промежуточные состояния, которые будут кешировать результаты вычислений и отслеживать зависимости, чтобы при их изменении сбрасывался и кеш.

## Примерение изменений к DOM

> Ок, данные мы подготовили, осталось показать их пользователю. 

![Перерисовывать DOM - это долго](sorted-visible-dom.svg)

> Решение в лоб - удалить старое дерево и вставить новое - мало того, что медленное, так ещё и может вызывать глюки типа "потери фокуса", "сброс позициии скроллинга в 0" и тому подобные. Короче, реальность упорно не хочет быть чистой функцией - для повышения отзывчивости нужно изменять существующее состояние, а не просто создавать новое.

## Виртуальный DOM

> Как подружить ужа с ежом? Правильно, давайте генерировать новый DOM всего приложения, а потом ~~React~~ специальная библиотека будет сравнивать его новую и старую версию и применять различия к тому DOM-у что видит пользователь.

![Кривые абстракции рождают чудовищ](visible-virtual-dom.svg)

> Звучит как костыль, не правда ли? Посмотрите на схему - сколько работы приходится выполнять только лишь для того, чтобы, когда пользователь меняет имя задачи, оно тут же менялось и в списке задач.

## Прямые зависимости

> Как могла бы выглядеть работа наиболее эффективного решения?

![Прямые зависимости. Что может быть эффективней?](visible-dom.svg)

> Всё просто - между исходными данными и их отображением устанавливаются прямые связи. При изменении одного состояния, изменяется и зависимое от него. Причём действует это не только между так называемыми "моделью" и "отображением", а между любыми зависимыми состояниями, начиная с базы данных на сервере, через кучу промежуточных состояний и заканчивая дом-узлом в браузере. Именно в этом и заключается суть Реактивного Программирования, а не в шаблонизаторе с созвучным названием, который продают нам на каждой конференции.

# Отслеживание зависимостей

## Тянуть или толкать?

Беконы, RX-ы и прочий стрим-панк слишком статичны, а реальные зависимости слишком сильно зависят от накликанного пользователем состояния.

## Сразу или потом?

Проблема KnockOutJS. Нельзя обновлять сразу, так как это приводит к лишним вычислениям, нужно делать это отложенно.

## А если в порядке увеличения глубины?

Проблема $jin.atom. Иногда приходится обновлять состояние только чтобы далее узнать, что зависимости от него больше нет.

## А если в порядке создания?

Проблема VueJS. Когда новые состояния зависят от старых начинаются проблемы.

## А если в порядке инициализации от корня?

Проблема ReactJS. Изменение в глубине приводит к пересчёту всей ветки до корня.

## А если исключительная ситуация?

Обычно исключения безвозвратно ломают приложение. Однако, исключение - такой же результат вычисления, как и собственно возвращаемое значение. Устранение причины исключения должно восстанавливать работу приложения. 

---

# Правильный алгоритм

## Построение графа зависимостей

Все вычисления происходят лениво. Между состояниями динамически строится направленный ациклический граф зависимостей. Каждый узел знает кто от него зависит и от кого он зависит.

## Каскадная инвалидация

Все зависимые узлы помечаются устаревшими, а косвенно зависимые - возможно устаревшими. Узел, от которого никто не зависит откладывается для последующего обновления.

## Отложенный пересчёт

Перед обновлением каждый узел убеждается в актуальности зависимостей в том же порядке, в котором они вычислялись ранее. И если хоть одна из них изменилась - обновляется и сам. 

## Покажите мне код!

Пример ООРП кода с использованием библиотеки $mol_mem c объяснением его работы.

# Асинхронщина

## Синхронный блокирующий

Код простой и понятный, но интерфейс замирает на неопределённое время.

## Асинхронный не блокирующий на стримах

Лапша многоразового использования, но конфигурация зависимостей задаётся статически.

## Синхронный неблокирующий async/await

Снова простой и понятный код, но много шума с async-await каскадно влияющего на интерфейсы, слабая кроссплатформенность.

## Синхронный неблокирующий на атомах

Простой и понятный код, абстрагирующий от асинхронности.

# Обратный поток данных

## Движение данных

Диаграмма взаимодействия полльзователя и сервера через интерфейс приложения.

## Двунаправленные зависимости

Диаграмма двусторонних биндингов в Angular. Отсутствие единственного источника истины порождает проблемы.

## "Однонаправленный" поток данных

Диаграмма FLUX. Проблема - обратный поток идёт в обход компонент, внутренняя кухня компонент просачивается в корень приложения.

## Изменяемые свойства как абстракция

Компонент выступает в роли посредника между вложенными компонентами и объемлющим, абстрагруя внешний слой от внутреннего и наоборот. Компоненты взаимодействуют лишь через свойства из которых можно что-то затянуть и в которые можно что-то затолкать. Что реально делается при этом полностью зависит от реализации геттеров и сеттеров этих свойств.

# Композиция компонент

## Абстракции

Компонент - обычный объект. Свойство - обычный полиморфный метод, который либо возвращает значение, либо устанавливает новое и возвращает актуальное.

## Переопределение

Переопределение свойств при создании как способ настройки поведения. 

## Связывание

Элегантное связывание свойств через переопределение. Двустороннее замещает свойство вложенного компонента свойством владельца (измерение одного приводит к естесственному изменению другого и наоборот). Левостороннее - только значением свойства владельца (вложенный компонент изменить значение не может). Правостороннее - свойство владельца вычисляется из свойства вложенного компонента (владелец изменить значение не может).

## Коммуникация

Связывание компонент друг с другом чере общего родителя.

## Реактивный рендеринг

Состояние dom-узла зависит от свойств компонента и от dom-узлов вложенных компонентов. Эта простая схема позволяет точечно обновлять DOM не производя лишних вычислений.

## Исключительные ситуации

Ошибки, ожидание загрузки и тп автоматически перехватываются и визуализируются. Это позволяет частям приложения падать и восстанавливать свою работу, не ломая других частей. 

# Ложка дёгтя

## Императивное изменение зависимости

Когда вам нужно изменить значение от которого вы зависите. Например - увеличить на 1. Красивого решения пока нет. Есть такое: для изменения запускать отдельную независимую реактивную задачу (самоуничтожающийся по завершении вычисления атом).

# Резюме

## Асинхронщина

Плюсы и минусы колбэков, обещаний, стримов, атомов.

## Парадигмы

Плюсы и минусы ООП, ФРП, ООРП.

## Реализации ООРП

Особенности реализаций $mol_atom, CellX, MobX, KO.

# Вопросы?
